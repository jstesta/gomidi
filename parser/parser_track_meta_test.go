package parser_test

import (
	"bytes"
	"io"
	"testing"

	"github.com/jstesta/gomidi/cfg"
	"github.com/jstesta/gomidi/midi"
	"github.com/jstesta/gomidi/parser"
)

var successMetaTrackTests = []struct {
	n        []byte
	expected *midi.Track
}{
	// known meta types specified by MIDI spec
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x6, 0x0, 0xff, 0x0, 0x2, 0xf, 0xff}, setupTrack1Event(0, 0, 2, []byte{0xf, 0xff})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x8, 0x1, 0xff, 0x1, 0x4, 't', 'e', 's', 't'}, setupTrack1Event(1, 1, 4, []byte{'t', 'e', 's', 't'})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x8, 0x2, 0xff, 0x2, 0x4, 't', 'e', 's', 't'}, setupTrack1Event(2, 2, 4, []byte{'t', 'e', 's', 't'})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x8, 0x3, 0xff, 0x3, 0x4, 't', 'e', 's', 't'}, setupTrack1Event(3, 3, 4, []byte{'t', 'e', 's', 't'})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x8, 0x4, 0xff, 0x4, 0x4, 't', 'e', 's', 't'}, setupTrack1Event(4, 4, 4, []byte{'t', 'e', 's', 't'})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x8, 0x5, 0xff, 0x5, 0x4, 't', 'e', 's', 't'}, setupTrack1Event(5, 5, 4, []byte{'t', 'e', 's', 't'})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x8, 0x6, 0xff, 0x6, 0x4, 't', 'e', 's', 't'}, setupTrack1Event(6, 6, 4, []byte{'t', 'e', 's', 't'})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x8, 0x7, 0xff, 0x7, 0x4, 't', 'e', 's', 't'}, setupTrack1Event(7, 7, 4, []byte{'t', 'e', 's', 't'})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x5, 0x8, 0xff, 0x20, 0x1, 0xb}, setupTrack1Event(8, 0x20, 1, []byte{0xb})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x4, 0x0, 0xff, 0x2F, 0x0}, setupTrack1Event(0, 0x2F, 0, []byte{})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x7, 0x0, 0xff, 0x51, 0x3, 0xA, 0xB, 0xC}, setupTrack1Event(0, 0x51, 3, []byte{0xA, 0xB, 0xC})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x9, 0x0, 0xff, 0x54, 0x5, 0xA, 0xB, 0xC, 0xD, 0xE}, setupTrack1Event(0, 0x54, 5, []byte{0xA, 0xB, 0xC, 0xD, 0xE})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x8, 0x0, 0xff, 0x58, 0x4, 0xA, 0xB, 0xC, 0xD}, setupTrack1Event(0, 0x58, 4, []byte{0xA, 0xB, 0xC, 0xD})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x6, 0x0, 0xff, 0x59, 0x2, 0xA, 0xB}, setupTrack1Event(0, 0x58, 2, []byte{0xA, 0xB})},
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x7, 0x0, 0xff, 0x7F, 0x3, 0xA, 0xB, 0xC}, setupTrack1Event(0, 0x7F, 3, []byte{0xA, 0xB, 0xC})},
	// unspecified meta type
	{[]byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x5, 0x1, 0xff, 0xBF, 0x1, 0xA}, setupTrack1Event(1, 0xBF, 1, []byte{0xA})},
}

func TestParseTrackMetaOK(t *testing.T) {

	for _, tt := range successMetaTrackTests {
		r := bytes.NewReader(tt.n)

		track, err := parser.ReadTrack(r, cfg.GomidiConfig{})
		if err != nil {
			t.Errorf("parser.ReadTrack: %v", err.Error())
		}

		for key, expected := range tt.expected.Events() {

			actual := track.Events()[key]

			if expected.Length() != actual.Length() || expected.DeltaTime() != actual.DeltaTime() || !bytes.Equal(expected.Data(), actual.Data()) {

				t.Errorf("parser.ReadTrack: expected %v, actual %v", expected, actual)
			}
		}
	}
}

func TestParseTrackMetaEOF(t *testing.T) {

	tt := []byte{'M', 'T', 'r', 'k', 0x0, 0x0, 0x0, 0x6, 0x0, 0xff}
	r := bytes.NewReader(tt)

	actual, err := parser.ReadTrack(r, cfg.GomidiConfig{})

	if err == nil {
		t.Errorf("parser.ReadTrack: expected error but succeeded, input=%d, n=%d", tt, actual)
	}

	if err != io.EOF {
		t.Errorf("parser.ReadTrack: expected io.EOF but was %v", err)
	}
}
